name: Release Build

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'Dry run (do not create release)'
        required: false
        default: 'true'
        type: boolean

permissions:
  contents: write
  id-token: write
  attestations: write
  pull-requests: write

env:
  CARGO_TERM_COLOR: always

jobs:
  build:
    name: Build (${{ matrix.target }})
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        include:
          # macOS x86_64
          - os: macos-latest
            target: x86_64-apple-darwin
            artifact_name: pybun-x86_64-apple-darwin
          # macOS ARM64
          - os: macos-latest
            target: aarch64-apple-darwin
            artifact_name: pybun-aarch64-apple-darwin
          # Linux x86_64 (glibc)
          - os: ubuntu-latest
            target: x86_64-unknown-linux-gnu
            artifact_name: pybun-x86_64-unknown-linux-gnu
          # Linux x86_64 (musl - static)
          - os: ubuntu-latest
            target: x86_64-unknown-linux-musl
            artifact_name: pybun-x86_64-unknown-linux-musl
          # Linux ARM64
          - os: ubuntu-latest
            target: aarch64-unknown-linux-gnu
            artifact_name: pybun-aarch64-unknown-linux-gnu
          # Windows x86_64 (stub for API stability)
          - os: windows-latest
            target: x86_64-pc-windows-msvc
            artifact_name: pybun-x86_64-pc-windows-msvc

    steps:
      - uses: actions/checkout@v4

      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}

      - name: Install cross-compilation tools (Linux ARM64)
        if: matrix.target == 'aarch64-unknown-linux-gnu'
        run: |
          sudo apt-get update
          sudo apt-get install -y gcc-aarch64-linux-gnu

      - name: Install musl tools
        if: matrix.target == 'x86_64-unknown-linux-musl'
        run: |
          sudo apt-get update
          sudo apt-get install -y musl-tools

      - name: Cache cargo
        uses: Swatinem/rust-cache@v2
        with:
          cache-targets: true
          key: ${{ matrix.target }}

      - name: Build release binary
        env:
          CARGO_TARGET_AARCH64_UNKNOWN_LINUX_GNU_LINKER: aarch64-linux-gnu-gcc
        run: |
          cargo build --release --target ${{ matrix.target }}

      - name: Create artifact directory
        shell: bash
        run: |
          mkdir -p dist/${{ matrix.artifact_name }}

      - name: Copy binary (Unix)
        if: runner.os != 'Windows'
        run: |
          cp target/${{ matrix.target }}/release/pybun dist/${{ matrix.artifact_name }}/pybun
          chmod +x dist/${{ matrix.artifact_name }}/pybun

      - name: Copy binary (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          Copy-Item "target/${{ matrix.target }}/release/pybun.exe" "dist/${{ matrix.artifact_name }}/pybun.exe"

      - name: Create tarball (Unix)
        if: runner.os != 'Windows'
        run: |
          cd dist
          tar -czvf ${{ matrix.artifact_name }}.tar.gz ${{ matrix.artifact_name }}

      - name: Create zip (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          cd dist
          Compress-Archive -Path ${{ matrix.artifact_name }} -DestinationPath ${{ matrix.artifact_name }}.zip

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.artifact_name }}
          path: |
            dist/${{ matrix.artifact_name }}.tar.gz
            dist/${{ matrix.artifact_name }}.zip
          if-no-files-found: error

  # Artifact size check
  check-size:
    name: Check artifact sizes
    runs-on: ubuntu-latest
    needs: build
    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: Check sizes
        run: |
          echo "=== Artifact Sizes ==="
          find artifacts -type f \( -name "*.tar.gz" -o -name "*.zip" \) -exec ls -lh {} \;
          echo ""
          echo "=== Size Check ==="
          # Fail if any artifact is larger than 50MB (adjustable threshold)
          MAX_SIZE=52428800  # 50MB in bytes
          for file in $(find artifacts -type f \( -name "*.tar.gz" -o -name "*.zip" \)); do
            size=$(stat -c%s "$file" 2>/dev/null || stat -f%z "$file" 2>/dev/null)
            if [ "$size" -gt "$MAX_SIZE" ]; then
              echo "WARNING: $file is larger than 50MB ($size bytes)"
            else
              echo "OK: $file ($size bytes)"
            fi
          done

  metadata:
    name: Release metadata
    runs-on: ubuntu-latest
    needs: build
    if: startsWith(github.ref, 'refs/tags/') || github.event_name == 'workflow_dispatch'
    steps:
      - uses: actions/checkout@v4

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: Resolve release metadata
        id: release_meta
        shell: bash
        run: |
          if [[ "$GITHUB_REF" == refs/tags/* ]]; then
            version="${GITHUB_REF#refs/tags/v}"
            channel="stable"
            release_tag="v${version}"
          else
            version=$(grep '^version' Cargo.toml | head -n1 | cut -d'"' -f2)
            channel="nightly"
            release_tag="nightly"
          fi
          published_at=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          base_url="https://github.com/${GITHUB_REPOSITORY}/releases/download/${release_tag}"
          release_url="https://github.com/${GITHUB_REPOSITORY}/releases/tag/${release_tag}"
          echo "version=${version}" >> $GITHUB_OUTPUT
          echo "channel=${channel}" >> $GITHUB_OUTPUT
          echo "release_tag=${release_tag}" >> $GITHUB_OUTPUT
          echo "base_url=${base_url}" >> $GITHUB_OUTPUT
          echo "release_url=${release_url}" >> $GITHUB_OUTPUT
          echo "published_at=${published_at}" >> $GITHUB_OUTPUT

      - name: Install minisign
        run: |
          sudo apt-get update
          sudo apt-get install -y minisign

      - name: Prepare minisign key
        id: minisign
        shell: bash
        run: |
          if [[ "${{ inputs.dry_run }}" == "true" ]]; then
            minisign -G -p /tmp/pybun-release.pub -s /tmp/pybun-release.key -c "pybun dry-run"
            echo "public_key=/tmp/pybun-release.pub" >> $GITHUB_OUTPUT
            echo "private_key=/tmp/pybun-release.key" >> $GITHUB_OUTPUT
            echo "mode=dummy" >> $GITHUB_OUTPUT
          else
            if [[ -z "${{ secrets.PYBUN_MINISIGN_PRIVATE_KEY }}" ]]; then
              echo "Missing PYBUN_MINISIGN_PRIVATE_KEY secret" >&2
              exit 1
            fi
            echo "${{ secrets.PYBUN_MINISIGN_PRIVATE_KEY }}" > /tmp/pybun-release.key
            chmod 600 /tmp/pybun-release.key
            echo "public_key=security/pybun-release.pub" >> $GITHUB_OUTPUT
            echo "private_key=/tmp/pybun-release.key" >> $GITHUB_OUTPUT
            echo "mode=release" >> $GITHUB_OUTPUT
          fi

      - name: Sign artifacts
        shell: bash
        run: |
          while IFS= read -r file; do
            minisign -Sm "$file" -s "${{ steps.minisign.outputs.private_key }}"
          done < <(find artifacts -type f \( -name "*.tar.gz" -o -name "*.zip" \))

      - name: Generate SBOM
        uses: anchore/sbom-action@v0
        with:
          path: artifacts
          format: cyclonedx-json
          output-file: pybun-sbom.json

      - name: Generate provenance
        run: |
          python3 scripts/release/generate_provenance.py \
            --assets-dir artifacts \
            --output pybun-provenance.json \
            --timestamp "${{ steps.release_meta.outputs.published_at }}"

      - name: Generate manifest and checksums
        run: |
          python3 scripts/release/generate_manifest.py \
            --assets-dir artifacts \
            --version "${{ steps.release_meta.outputs.version }}" \
            --channel "${{ steps.release_meta.outputs.channel }}" \
            --base-url "${{ steps.release_meta.outputs.base_url }}" \
            --release-url "${{ steps.release_meta.outputs.release_url }}" \
            --published-at "${{ steps.release_meta.outputs.published_at }}" \
            --public-key "${{ steps.minisign.outputs.public_key }}" \
            --sbom pybun-sbom.json \
            --provenance pybun-provenance.json \
            --output pybun-release.json \
            --checksums SHA256SUMS

      - name: Attest build provenance
        uses: actions/attest-build-provenance@v1
        with:
          subject-path: |
            artifacts/**/*.tar.gz
            artifacts/**/*.zip

      - name: Attest SBOM
        uses: actions/attest-sbom@v1
        with:
          sbom-path: pybun-sbom.json
          subject-path: |
            artifacts/**/*.tar.gz
            artifacts/**/*.zip

      - name: Upload release metadata
        uses: actions/upload-artifact@v4
        with:
          name: release-metadata
          path: |
            SHA256SUMS
            pybun-release.json
            pybun-provenance.json
            pybun-sbom.json
            artifacts/**/*.minisig

  package-managers:
    name: Update package manager manifests
    runs-on: ubuntu-latest
    needs: metadata
    if: startsWith(github.ref, 'refs/tags/')
    steps:
      - uses: actions/checkout@v4
        with:
          ref: main

      - name: Download release metadata
        uses: actions/download-artifact@v4
        with:
          name: release-metadata
          path: release-metadata

      - name: Read release version
        id: release_version
        shell: bash
        run: |
          version="$(python3 - <<'PY'
          import json
          with open("release-metadata/pybun-release.json", "r", encoding="utf-8") as handle:
              print(json.load(handle)["version"])
          PY
          )"
          echo "version=${version}" >> "$GITHUB_OUTPUT"

      - name: Generate package manager manifests
        run: |
          python3 scripts/release/generate_package_managers.py \
            --manifest release-metadata/pybun-release.json \
            --checksums release-metadata/SHA256SUMS \
            --homebrew Formula/pybun.rb \
            --scoop bucket/pybun.json \
            --winget winget/pybun.yaml

      - name: Create pull request
        uses: peter-evans/create-pull-request@v6
        with:
          title: "chore(release): update package managers for v${{ steps.release_version.outputs.version }}"
          body: "Automated update for Homebrew/Scoop/winget manifests."
          commit-message: "chore(release): update package managers for v${{ steps.release_version.outputs.version }}"
          branch: "automation/package-managers-v${{ steps.release_version.outputs.version }}"
          delete-branch: true

  # Release job (only on tags)
  release:
    name: Create Release
    runs-on: ubuntu-latest
    needs: [build, check-size, metadata]
    if: startsWith(github.ref, 'refs/tags/') && !inputs.dry_run
    steps:
      - uses: actions/checkout@v4

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: Download release metadata
        uses: actions/download-artifact@v4
        with:
          name: release-metadata
          path: release-metadata

      - name: Create release
        uses: softprops/action-gh-release@v2
        with:
          files: |
            artifacts/**/*.tar.gz
            artifacts/**/*.zip
            release-metadata/**/*.minisig
            release-metadata/SHA256SUMS
            release-metadata/pybun-release.json
            release-metadata/pybun-provenance.json
            release-metadata/pybun-sbom.json
          draft: true
          generate_release_notes: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # Codesign placeholder (for future implementation)
  codesign-placeholder:
    name: Codesign (placeholder)
    runs-on: ubuntu-latest
    needs: build
    if: startsWith(github.ref, 'refs/tags/')
    steps:
      - name: Codesign placeholder
        run: |
          echo "=== Codesign Placeholder ==="
          echo "This step will be implemented when code signing is required."
          echo "Required secrets for future implementation:"
          echo "  - APPLE_CERTIFICATE (for macOS notarization)"
          echo "  - APPLE_CERTIFICATE_PASSWORD"
          echo "  - APPLE_ID"
          echo "  - APPLE_TEAM_ID"
          echo "  - WINDOWS_CERTIFICATE (for Windows signing)"
          echo ""
          echo "Current status: NOT IMPLEMENTED (stub)"
